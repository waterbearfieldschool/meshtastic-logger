<!DOCTYPE html>
<html>
<head>
  <title>Meshtastic Contact Visualizer</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    body { margin:0; padding:0; }
    #map { width:100vw; height:100vh; }
  </style>
</head>
<body>
  <div id="map"></div>
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    const map = L.map('map').setView([42.37, -71.20], 13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: 'Â© OpenStreetMap contributors'
    }).addTo(map);

    const ownPath = [];
    const ownPolyline = L.polyline(ownPath, {color:'blue'}).addTo(map);
    const contactsLayer = L.layerGroup().addTo(map);
    const seenContacts = new Set();

    const knownIcon = L.icon({
      iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',
      iconSize: [25,41],
      iconAnchor: [12,41]
    });
    const unknownIcon = L.divIcon({
      html: '<div style="width:20px;height:20px;border-radius:50%;background:rgba(255,165,0,0.5);border:1px dashed #f80;"></div>',
      className: ''
    });
    const selfIcon = L.divIcon({
      html: '<div style="width:12px;height:12px;border-radius:50%;background:#0088ff;border:2px solid white;"></div>',
      className: ''
    });

    async function parseAndPlot() {
      const resp = await fetch('log.csv?' + Date.now());
      const text = await resp.text();
      const lines = text.trim().split('\n');
      const header = lines.shift().split(',');
      const idx = {};
      header.forEach((h, i) => idx[h] = i);

      lines.forEach(line => {
        const cols = line.split(',');
        const timestamp = cols[idx['timestamp']];
        const ourLatStr = cols[idx['our_latitude']];
        const ourLonStr = cols[idx['our_longitude']];
        const nodeId = cols[idx['node_id']];
        const nodeName = cols[idx['node_name']];
        const nodeLatStr = cols[idx['node_latitude']];
        const nodeLonStr = cols[idx['node_longitude']];

        const ourLat = parseFloat(ourLatStr);
        const ourLon = parseFloat(ourLonStr);
        const nodeLat = nodeLatStr ? parseFloat(nodeLatStr) : null;
        const nodeLon = nodeLonStr ? parseFloat(nodeLonStr) : null;

        const hasOwnPos = !isNaN(ourLat) && !isNaN(ourLon);
        const hasNodePos = nodeLat !== null && !isNaN(nodeLat) && nodeLon !== null && !isNaN(nodeLon);

        if (!hasOwnPos) return;

        const fromLatLng = [ourLat, ourLon];
        ownPath.push(fromLatLng);
        ownPolyline.setLatLngs(ownPath);

        const contactKey = `${timestamp}_${nodeId}`;
        if (seenContacts.has(contactKey)) return;
        seenContacts.add(contactKey);

        L.marker(fromLatLng, { icon: selfIcon })
          .bindPopup(`You @ ${timestamp}`)
          .addTo(contactsLayer);

        if (hasNodePos) {
          const nodeLatLng = [nodeLat, nodeLon];
          L.marker(nodeLatLng, { icon: knownIcon })
            .bindPopup(`${nodeName} @ ${timestamp}`)
            .addTo(contactsLayer);
          L.polyline([fromLatLng, nodeLatLng], { color: 'green' }).addTo(contactsLayer);
        } else {
          L.marker(fromLatLng, { icon: unknownIcon })
            .bindPopup(`${nodeName} (no position) @ ${timestamp}`)
            .addTo(contactsLayer);
          const stub = [
            fromLatLng,
            [fromLatLng[0], fromLatLng[1] + 0.0004]
          ];
          L.polyline(stub, { color: 'orange', dashArray: '4,4' }).addTo(contactsLayer);
        }
      });

      const bounds = ownPolyline.getBounds().extend(contactsLayer.getBounds());
      if (bounds.isValid()) {
        map.fitBounds(bounds, { maxZoom: 16 });
      }
    }

    parseAndPlot();
    setInterval(parseAndPlot, 60 * 1000);
  </script>
</body>
</html>
